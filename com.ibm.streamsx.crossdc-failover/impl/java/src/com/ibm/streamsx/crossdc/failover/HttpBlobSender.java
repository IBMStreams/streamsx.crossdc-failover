/*
===================================================
# Licensed Materials - Property of IBM
# Copyright IBM Corp. 2018, 2019
# US Government Users Restricted Rights - Use, duplication or
# disclosure restricted by GSA ADP Schedule Contract with
# IBM Corp.
===================================================
*/
/* Generated by Streams Studio: October 8, 2018 at 8:00:04 AM EDT */
/*
===================================================
First created on: Oct/08/2018
Last modified on: Apr/15/2019

This custom Java operator allows us to do a HTTP POST of
any binary content to the given URL. That URL must be hosted at the
receiving end via a Streams HTTPBlobInjection operator. This code is tested to
send binary data only to be received by that particular Streams operator.
This operator was originally developed to be used inside the
streamsx.crossdc-failover toolkit.
===================================================
*/
package com.ibm.streamsx.crossdc.failover;

import org.apache.log4j.Logger;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.StreamingOutput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPortSet.WindowMode;
import com.ibm.streams.operator.model.InputPortSet.WindowPunctuationInputMode;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.OutputPortSet;
import com.ibm.streams.operator.model.OutputPortSet.WindowPunctuationOutputMode;
import com.ibm.streams.operator.model.OutputPorts;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;

import java.io.*;
import java.net.*;
import java.util.ArrayList;

/**
 * Class for an operator that receives a tuple and then optionally submits a tuple. 
 * This pattern supports one or more input streams and one or more output streams. 
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li> 
 * <li>process() handles a tuple arriving on an input port 
 * <li>processPuncuation() handles a punctuation mark arriving on an input port 
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time, 
 * such as a request to stop a PE or cancel a job. 
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks, 
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other, 
 * which lead to these methods being called concurrently by different threads.</p> 
 */
@PrimitiveOperator(name="HttpBlobSender", namespace="com.ibm.streamsx.crossdc.failover",
description="Java Operator HttpBlobSender")
@InputPorts({@InputPortSet(description="Port that ingests tuples", cardinality=1, optional=false, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious), @InputPortSet(description="Optional input ports", optional=true, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious)})
@OutputPorts({@OutputPortSet(description="Port that produces tuples", cardinality=1, optional=false, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating), @OutputPortSet(description="Optional output ports", optional=true, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating)})
public class HttpBlobSender extends AbstractOperator {
	private ArrayList<String> urlList;
	private String remoteMachineThatAcceptedThePreviousConnection = "";
	private String remoteMachineNames = "";
	private int remoteHttpPort = 0;
	private String remoteUrlPath = "";
	private boolean sendToAllRemoteMachines = false;
	private String binaryDataAttributeName = "";
	private boolean alwaysLogHttpErrors = false;
	private int httpConnectionTimeout = 25;
	private int httpReadTimeout = 100;
	
    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
	@Override
	public synchronized void initialize(OperatorContext context)
			throws Exception {
    	// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO:
        // If needed, insert code to establish connections or resources to communicate an external system or data store.
        // The configuration information for this may come from parameters supplied to the operator invocation, 
        // or external configuration files or a combination of the two.
        // 
        // Users are allowed to configure this operator with one or more remote machines.
        // If they specify more than one machine, it will be via a comma separated string.
        // e-g: "Machine1,Machine2,Machine3,Machine4,Machine5"
        // Let us parse that string and get all the remote machine names stored in a String list.
        String[] machines = remoteMachineNames.split(",");
        // Let us now populate the URL array list.
        urlList = new ArrayList<String>();
        
        for (String str: machines) {
        	// Insert the fully formed URL with the proper HTTP syntax into the list.
        	urlList.add("http://" + str + ":" + remoteHttpPort + remoteUrlPath);
        }
	}

    /**
     * Notification that initialization is complete and all input and output ports 
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
    	// This method is commonly used by source operators. 
    	// Operators that process incoming tuples generally do not need this notification. 
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    }

    /**
     * Process an incoming tuple that arrived on the specified port.
     * <P>
     * Copy the incoming tuple to a new output tuple and submit to the output port. 
     * </P>
     * @param inputStream Port the tuple is arriving on.
     * @param tuple Object representing the incoming tuple.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public final void process(StreamingInput<Tuple> inputStream, Tuple tuple)
            throws Exception {
    	// Create a new tuple for output port 0
        StreamingOutput<OutputTuple> outStream = getOutput(0);
        OutputTuple outTuple = outStream.newTuple();

        // Copy across all matching attributes.
        outTuple.assign(tuple);

		// Establish a connection with the given Streams application URL for posting the given binary content.
    	// Users are allowed to configure this operator with one or more remote machines.
    	// So, if the user configured more than one remote machine, we need to go through the URL list and
    	// keep connecting. There is actually more to that. User may also configure this operator to send the blob to
    	// all the remote machines. In that case, we have to connect to them one by one and send the blob.
    	// If any remote machine refuses our connection, we will log that and simply move on to the next one.
    	// If the user configured not to send the blob to all the remote machines, then we have to send only to
    	// a remote machine that accepts our connection. In this particular case of sending to only one
    	// remote machine, we can save the remote machine name that accepted our connection, and directly send it
    	// to that machine every time in the future without having to iterating over the list. This is a minor optimization.
        int sizeOfUrlList = urlList.size();
        
    	for (int idx=0; idx<sizeOfUrlList; idx++) {
    		String url = urlList.get(idx);
    		
    		if (sendToAllRemoteMachines == false && remoteMachineThatAcceptedThePreviousConnection != "") {
    			// We can directly send it to the remote machine that accepted our previous connection attempt.
    			url = remoteMachineThatAcceptedThePreviousConnection;
    		}
    		
    		try {
		        URL serverUrl = new URL(url);
		        HttpURLConnection postUrlConnection = (HttpURLConnection)serverUrl.openConnection();
		        postUrlConnection.setConnectTimeout(httpConnectionTimeout * 1000); // Default: 25 seconds
		        postUrlConnection.setReadTimeout(httpReadTimeout * 1000); // Default: 100 seconds
				// Set the output to true needed for POSTing data via HTTP.
				postUrlConnection.setDoOutput(true);
				postUrlConnection.setRequestMethod("POST");
				// IBM Streams BlobInjection HTTP server at the receiving end requires  
				// this particular content type header when posting the binary content.
				postUrlConnection.addRequestProperty("Content-Type", "application/octet-stream");
				OutputStream outputStreamToRequestBody = postUrlConnection.getOutputStream();
				// Prepare an output stream writer that can do a buffered writing of the binary content.
				BufferedWriter httpRequestBodyWriter = 
					new BufferedWriter(new OutputStreamWriter(outputStreamToRequestBody));
				// Write the binary data to the output stream writer.
				outputStreamToRequestBody.write(
					tuple.getBlob(binaryDataAttributeName).getData(), 0, 
					(int)tuple.getBlob(binaryDataAttributeName).getLength());
				// All the binary contents have been sent. Flush the output stream.
				outputStreamToRequestBody.flush();
				// Close the output stream.
				outputStreamToRequestBody.close();
				// Close the request body writer even though we didn't send any non-binary content.
				httpRequestBodyWriter.close();
	
				// IMPORTANT TIP.
				// We must attempt to read the POST response code from the URL connection.
				// Even though there will be no response text from the given IBM Streams application URL,
				// this logic must be done to trigger the HTTP POST request to be sent to the remote server.
				int responseCode;
				StringBuffer response = new StringBuffer();
				String inputLine = "";
				String responseString = "";
				responseCode = postUrlConnection.getResponseCode();
				
				try {
					// Read if there is any response text.
					BufferedReader in = new BufferedReader(
						new InputStreamReader(postUrlConnection.getInputStream()));
						
					while ((inputLine = in.readLine()) != null) {
						response.append(inputLine);
					}
						
					in.close();
					responseString = response.toString();
				} catch(Exception ex) {
					// When sending the Blob data to the remote HTTPBlobInjection operator,
					// it will not reply with any content back.
					// In that case, this exception is normal. Ignore this exception.
				}
				
				postUrlConnection.disconnect();
				
				// Since the IBM Streams BlobInjection HTTP server on the other end will not 
				// reply with any content, it will send us back HTTP_NO_CONTENT 
				// i.e. 204 as a successful response code.
				if (responseCode == HttpURLConnection.HTTP_NO_CONTENT ||
					responseCode == HttpURLConnection.HTTP_OK) {
					Logger.getLogger(this.getClass()).
						info(tuple.getBlob(binaryDataAttributeName).getLength() +
						" bytes have been sent to this URL: " + url);
					
					if (sendToAllRemoteMachines == true) {
						// Continue the loop to connect and send the blob to the 
						// other remote machines in the URL list.
						continue;
					} else {
						// User has configured to send it just to any one of the configured
						// remote machines that can accept our connection and receive our blob data.
						// So, we are done. Record the remote machine name for future use.
						remoteMachineThatAcceptedThePreviousConnection = url;
						return;
					}
				} else {
					if (alwaysLogHttpErrors == true) {
						Logger.getLogger(this.getClass()).
							error("Error in posting the binary contents to this URL: " + url);
						Logger.getLogger(this.getClass()).
							error(tuple.getBlob(binaryDataAttributeName).getLength() + 
							" bytes of binary data was attempted to be sent to that URL.");
						Logger.getLogger(this.getClass()).
							error("HTTP response code=" + responseCode);
						Logger.getLogger("HTTP response message=" + 
							this.getClass()).error(responseString);
					} else {
						Logger.getLogger(this.getClass()).
						info("Error in posting the binary contents to this URL: " + url);
						Logger.getLogger(this.getClass()).
							info(tuple.getBlob(binaryDataAttributeName).getLength() + 
							" bytes of binary data was attempted to be sent to that URL.");
						Logger.getLogger(this.getClass()).
							info("HTTP response code=" + responseCode);
						Logger.getLogger("HTTP response message=" + 
							this.getClass()).info(responseString);						
					}
		
					// If there are any abnormal HTTP errors, send the response code and
					// the response message in an output tuple.
			        outTuple.setInt("responseCode", responseCode);
			        outTuple.setString("responseMessage", responseString);
			        // Submit new tuple to output port 0
			        outStream.submit(outTuple);
			        
		        	if (sendToAllRemoteMachines == false && url == remoteMachineThatAcceptedThePreviousConnection) {
		        		// Safely reset this member variable.
		        		remoteMachineThatAcceptedThePreviousConnection = "";
		        		
		        		if (sizeOfUrlList > 1) {
			        		// The last known good remote machine encountered an error.
			        		// If more machines are configured, we can try to find another 
			        		// good remote machine that will accept our connection.
			        		// Reset the index to -1 to go through the entire list from the 0th element in the next go around.
			        		idx = -1;
		        		}
		        	}
		        	
		        	continue;
				}
	        } catch (Exception ex) {
	        	// We encountered an exception in the HTTP layer.
	        	// It could be related to connection refused or other HTTP socket errors.
	        	// We will display the error right here.
	        	StringWriter sw = new StringWriter();
	        	ex.printStackTrace(new PrintWriter(sw));
	        	Logger.getLogger(this.getClass()).
	        		error("Exception while communicating with " + 
	    			url + ". Error message: " + sw.toString());
	        	
	        	if (sendToAllRemoteMachines == false && url == remoteMachineThatAcceptedThePreviousConnection) {
	        		// Safely reset this member variable.
	        		remoteMachineThatAcceptedThePreviousConnection = "";
	        		
	        		if (sizeOfUrlList > 1) {
		        		// The last known good remote machine encountered an error.
		        		// If more machines are configured, we can try to find another 
		        		// good remote machine that will accept our connection.
		        		// Reset the index to -1 to go through the entire list from the 0th element in the next go around.
		        		idx = -1;
	        		}
	        	}
	        	
	        	continue;
	        }
        } // End of for loop.
    }
    
    /**
     * Process an incoming punctuation that arrived on the specified port.
     * @param stream Port the punctuation is arriving on.
     * @param mark The punctuation mark
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public void processPunctuation(StreamingInput<Tuple> stream,
    		Punctuation mark) throws Exception {
    	// For window markers, punctuate all output ports 
    	super.processPunctuation(stream, mark);
    }

    /**
     * Shutdown this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    public synchronized void shutdown() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO: If needed, close connections or release resources related to any external system or data store.

        // Must call super.shutdown()
        super.shutdown();
    }

    @Parameter(name="remoteMachineNames",
    	description="Specify one or more remote machines or IP addresses inside a string with comma separators as needed.",
    	optional=false)
    public void setRemoteMachineNames(String str) {
    	remoteMachineNames = str;
    }
    
    @Parameter(name="remoteHttpPort",
        description="Specify the remote HTTP port where to connect and send data.",
        optional=false)
    public void setRemoteHttpPort(int port) {
    	remoteHttpPort = port;
    }

    @Parameter(name="remoteUrlPath",
    	description="Specify the URL path component of the remote machine's URL.",
    	optional=false)
    public void setRemoteUrlPath(String path) {
    	remoteUrlPath = path;
    }

    @Parameter(name="sendToAllRemoteMachines",
		description="Specify whether to send the blob data to all the " + 
			"remote machines or only to the first successful machine that " +
			"accepts the HTTP connection request.",
		optional=true)
    public void setSendToAllRemoteMachines(boolean value) {
    	sendToAllRemoteMachines = value;
    }
    
    @Parameter(name="binaryDataAttributeName", 
		description="Specify the attribute name that will carry the binary data.", optional=false)
    public void setBinaryDataAttributeName(String _attributeName) {
    	binaryDataAttributeName = _attributeName;
    }
    
    @Parameter(name="alwaysLogHttpErrors",
    	description="Specify whether to log the HTTP errors at all times.", optional=true)
    public void setAlwaysLogHttpErrors(boolean value) {
    	alwaysLogHttpErrors = value;
    }

    @Parameter(name="httpConnectionTimeout",
    	description="Specify the HTTP connection timeout in number of seconds.", optional=true)
	public void setHttpConnectionTimeout(int value) {
		httpConnectionTimeout = value;
	}
	
    @Parameter(name="httpReadTimeout",
    	description="Specify the HTTP read timeout in number of seconds.", optional=true)
	public void setHttpReadTimeout(int value) {
		httpReadTimeout = value;
	}
}

